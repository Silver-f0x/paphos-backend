
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>actions: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">paphos/actions/app.go (66.7%)</option>
				
				<option value="file1">paphos/actions/characters.go (71.4%)</option>
				
				<option value="file2">paphos/actions/render.go (100.0%)</option>
				
				<option value="file3">paphos/actions/users.go (77.8%)</option>
				
				<option value="file4">paphos/models/character.go (0.0%)</option>
				
				<option value="file5">paphos/models/models.go (83.3%)</option>
				
				<option value="file6">paphos/models/user.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package actions

import (
        "errors"
        "net/http"
        "sync"

        "paphos/locales"
        "paphos/models"
        "paphos/shared"

        "github.com/gobuffalo/buffalo"
        "github.com/gobuffalo/buffalo-pop/v3/pop/popmw"
        "github.com/gobuffalo/envy"
        contenttype "github.com/gobuffalo/mw-contenttype"
        forcessl "github.com/gobuffalo/mw-forcessl"
        i18n "github.com/gobuffalo/mw-i18n/v2"
        paramlogger "github.com/gobuffalo/mw-paramlogger"
        "github.com/gobuffalo/x/sessions"
        "github.com/rs/cors"
        "github.com/unrolled/secure"
)

// ENV is used to help switch settings based on where the
// application is being run. Default is "development".
var ENV = envy.Get("GO_ENV", "development")

var (
        app     *buffalo.App
        appOnce sync.Once
        T       *i18n.Translator
)

// App is where all routes and middleware for buffalo
// should be defined. This is the nerve center of your
// application.
//
// Routing, middleware, groups, etc... are declared TOP -&gt; DOWN.
// This means if you add a middleware to `app` *after* declaring a
// group, that group will NOT have that new middleware. The same
// is true of resource declarations as well.
//
// It also means that routes are checked in the order they are declared.
// `ServeFiles` is a CATCH-ALL route, so it should always be
// placed last in the route declarations, as it will prevent routes
// declared after it to never be called.
func App() *buffalo.App <span class="cov8" title="1">{
        appOnce.Do(func() </span><span class="cov8" title="1">{
                app = buffalo.New(buffalo.Options{
                        Env:          ENV,
                        SessionStore: sessions.Null{},
                        PreWares: []buffalo.PreWare{
                                cors.Default().Handler,
                        },
                        SessionName: "_paphos_session",
                })

                // By default, Buffallo returns HTTP 500 with text "EOF" when a client sends
                // a bad payload. That's not _our_ fault though, so we'll replace that with
                // a 400 so our logs actually reflect that there was nothing wrong on our
                // side.
                var originalError500Handler = app.ErrorHandlers[500]
                app.ErrorHandlers[http.StatusInternalServerError] = func(status int, err error, c buffalo.Context) error </span><span class="cov0" title="0">{
                        if err.Error() == "EOF" </span><span class="cov0" title="0">{
                                status = http.StatusBadRequest
                                err = c.Error(http.StatusBadRequest, errors.New("malformed request payload"))
                        }</span>

                        <span class="cov0" title="0">return originalError500Handler(status, err, c)</span>
                }
                // TODO(11b): related to the above ^
                // Marshalling failures result in a 500 even though they're the user's fault
                // most of the time (e.g. sent in an int instead of a string), fix that.

                // Automatically redirect to SSL
                <span class="cov8" title="1">app.Use(forceSSL())

                // Log request parameters (filters apply).
                app.Use(paramlogger.ParameterLogger)

                // Set the request content type to JSON
                app.Use(contenttype.Set("application/json"))

                // Wraps each request in a transaction.
                //   c.Value("tx").(*pop.Connection)
                // Remove to disable this.
                app.Use(popmw.Transaction(models.DB))

                apiV1Group := app.Group("/api/v1")
                userGroup := apiV1Group.Group("/users")
                userGroup.POST("/register", UsersRegisterPost)
                userGroup.POST("/login", UsersLoginPost)

                apiV1Group.Use(shared.ExtractDataFromJWTMiddleware)

                apiV1Group.Resource("/characters", CharactersResource{})</span>

                // Disabled for now since we don't need this in the front-end yet and it
                // leaks user emails.
                // userGroup.GET("/{user_id}", UsersShowGet)
        })

        <span class="cov8" title="1">return app</span>
}

// translations will load locale files, set up the translator `actions.T`,
// and will return a middleware to use to load the correct locale for each
// request.
// for more information: https://gobuffalo.io/en/docs/localization
func translations() buffalo.MiddlewareFunc <span class="cov0" title="0">{
        var err error
        if T, err = i18n.New(locales.FS(), "en-US"); err != nil </span><span class="cov0" title="0">{
                app.Stop(err)
        }</span>
        <span class="cov0" title="0">return T.Middleware()</span>
}

// forceSSL will return a middleware that will redirect an incoming request
// if it is not HTTPS. "http://example.com" =&gt; "https://example.com".
// This middleware does **not** enable SSL. for your application. To do that
// we recommend using a proxy: https://gobuffalo.io/en/docs/proxy
// for more information: https://github.com/unrolled/secure/
func forceSSL() buffalo.MiddlewareFunc <span class="cov8" title="1">{
        return forcessl.Middleware(secure.Options{
                SSLRedirect:     ENV == "production",
                SSLProxyHeaders: map[string]string{"X-Forwarded-Proto": "https"},
        })
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package actions

import (
        "fmt"
        "net/http"

        "github.com/gobuffalo/buffalo"
        "github.com/gobuffalo/pop/v6"

        "paphos/models"
        "paphos/shared"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Character)
// DB Table: Plural (characters)
// Resource: Plural (Characters)
// Path: Plural (/characters)
// View Template Folder: Plural (/templates/characters/)

// CharactersResource is the resource for the Character model
type CharactersResource struct {
        buffalo.Resource
}

// List gets all Characters. This function is mapped to the path
// GET /characters
func (v CharactersResource) List(c buffalo.Context) error <span class="cov8" title="1">{
        // Get the DB connection from the context
        tx, ok := c.Value("tx").(*pop.Connection)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no transaction found")
        }</span>

        <span class="cov8" title="1">characters := &amp;models.Characters{}

        // Paginate results. Params "page" and "per_page" control pagination.
        // Default values are "page=1" and "per_page=20".
        q := tx.PaginateFromParams(c.Params())

        // Retrieve visible Characters from the DB
        userUuid, err := shared.ExtractUserUUIDFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := q.
                Scope(models.CharactersVisibleToUser(userUuid)).
                Select(models.FieldsForCharacterList...).
                All(characters); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Render(200, r.JSON(characters))</span>
}

// Show gets the data for one Character. This function is mapped to
// the path GET /characters/{character_id}
func (v CharactersResource) Show(c buffalo.Context) error <span class="cov8" title="1">{
        // Get the DB connection from the context
        tx, ok := c.Value("tx").(*pop.Connection)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no transaction found")
        }</span>

        // Allocate an empty Character
        <span class="cov8" title="1">character := &amp;models.Character{}

        // To find the Character the parameter character_id is used.
        userUuid, err := shared.ExtractUserUUIDFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // FIXME(11b): This makes it so unlisted characters can't be used. Need to
        // break this into two separate scopes.
        <span class="cov8" title="1">if err := tx.Where("id = ?", c.Param("character_id")).Scope(models.CharactersVisibleToUser(userUuid)).First(character); err != nil </span><span class="cov8" title="1">{
                return c.Error(http.StatusNotFound, fmt.Errorf("character not found"))
        }</span>

        <span class="cov8" title="1">return c.Render(200, r.JSON(character))</span>
}

// Create adds a Character to the DB. This function is mapped to the
// path POST /characters
func (v CharactersResource) Create(c buffalo.Context) error <span class="cov8" title="1">{
        // Allocate an empty Character
        character := &amp;models.Character{}

        // Bind character to the html form elements
        if err := c.Bind(character); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the DB connection from the context
        <span class="cov8" title="1">tx, ok := c.Value("tx").(*pop.Connection)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no transaction found")
        }</span>

        // Attach ID of the creator to the character
        <span class="cov8" title="1">userUuid, err := shared.ExtractUserUUIDFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">character.CreatorID = userUuid

        // Validate the data from the html form
        verrs, err := tx.ValidateAndCreate(character)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if verrs.HasAny() </span><span class="cov0" title="0">{
                return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }</span>

        <span class="cov8" title="1">return c.Render(http.StatusCreated, r.JSON(character))</span>
}

// Update changes a Character in the DB. This function is mapped to
// the path PUT /characters/{character_id}
func (v CharactersResource) Update(c buffalo.Context) error <span class="cov8" title="1">{
        // Get the DB connection from the context
        tx, ok := c.Value("tx").(*pop.Connection)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no transaction found")
        }</span>

        // Allocate an empty Character
        <span class="cov8" title="1">character := &amp;models.Character{}

        if err := tx.Find(character, c.Param("character_id")); err != nil </span><span class="cov0" title="0">{
                return c.Error(http.StatusNotFound, err)
        }</span>

        <span class="cov8" title="1">userUuid, err := shared.ExtractUserUUIDFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if character.CreatorID != userUuid </span><span class="cov8" title="1">{
                return c.Error(http.StatusForbidden, fmt.Errorf("forbidden"))
        }</span>

        // Bind Character to the html form elements
        <span class="cov8" title="1">if err := c.Bind(character); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">verrs, err := tx.ValidateAndUpdate(character)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if verrs.HasAny() </span><span class="cov0" title="0">{
                return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }</span>

        <span class="cov8" title="1">return c.Render(http.StatusOK, r.JSON(character))</span>
}

// TODO(11b): Implement in the near future. Take care to send a good error
// message when deletion fails due to foreign key constraints.
/*
// Destroy deletes a Character from the DB. This function is mapped
// to the path DELETE /characters/{character_id}
func (v CharactersResource) Destroy(c buffalo.Context) error {
        // Get the DB connection from the context
        tx, ok := c.Value("tx").(*pop.Connection)
        if !ok {
                return fmt.Errorf("no transaction found")
        }

        // Allocate an empty Character
        character := &amp;models.Character{}

        // To find the Character the parameter character_id is used.
        if err := tx.Find(character, c.Param("character_id")); err != nil {
                return c.Error(http.StatusNotFound, err)
        }

        if err := tx.Destroy(character); err != nil {
                return err
        }

        return c.Render(http.StatusOK, r.JSON(character))
}
*/
</pre>
		
		<pre class="file" id="file2" style="display: none">package actions

import (
        "github.com/gobuffalo/buffalo/render"
)

var r *render.Engine

func init() <span class="cov8" title="1">{
        r = render.New(render.Options{
                DefaultContentType: "application/json",
        })
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package actions

import (
        "fmt"
        "net/http"

        "github.com/gobuffalo/buffalo"
        "github.com/gobuffalo/pop/v6"
        "github.com/gobuffalo/validate/v3"
        "github.com/gofrs/uuid"

        "paphos/models"
        "paphos/shared"
)

// Commented out for now to avoid data leakage. Adjust when we actually need
// this data in the front-end.
/* func UsersShowGet(c buffalo.Context) error {
        tx, ok := c.Value("tx").(*pop.Connection)
        if !ok {
                return fmt.Errorf("no transaction found")
        }

        user := &amp;models.User{}
        if err := tx.Find(user, c.Param("user_id")); err != nil {
                return c.Error(http.StatusNotFound, err)
        }

        return c.Render(200, r.JSON(user))
} */

// UsersRegisterPost registers a new User.
func UsersRegisterPost(c buffalo.Context) error <span class="cov8" title="1">{
        // Allocate an empty User
        user := &amp;models.User{}

        // Bind user to the request body payload
        if err := c.Bind(user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the DB connection from the context
        <span class="cov8" title="1">tx, ok := c.Value("tx").(*pop.Connection)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no transaction found")
        }</span>

        // Validate the data from the request
        <span class="cov8" title="1">verrs, err := user.Create(tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if verrs.HasAny() </span><span class="cov8" title="1">{
                return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
        }</span>

        <span class="cov8" title="1">return c.Render(http.StatusCreated, r.JSON(user))</span>
}

// UsersLoginPost logs a user in by returning a session JWT.
func UsersLoginPost(c buffalo.Context) error <span class="cov8" title="1">{
        user := &amp;models.User{}

        if err := c.Bind(user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tx, ok := c.Value("tx").(*pop.Connection)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no transaction found")
        }</span>

        <span class="cov8" title="1">populated_user, err := user.Authorize(tx)
        if err != nil </span><span class="cov8" title="1">{
                verrs := validate.NewErrors()
                verrs.Add("root", "Invalid email or password.")
                return c.Error(http.StatusUnauthorized, verrs)
        }</span>

        <span class="cov8" title="1">tokenString, err := shared.CreateSignedJWTStringForUser(populated_user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Render(http.StatusCreated, r.JSON(struct {
                ID          uuid.UUID `json:"id"`
                Email       string    `json:"email"`
                DisplayName string    `json:"display_name"`
                JWT         string    `json:"jwt"`
        }{populated_user.ID, populated_user.Email, populated_user.DisplayName, tokenString}))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "time"

        "github.com/gobuffalo/nulls"
        "github.com/gobuffalo/pop/v6"
        "github.com/gobuffalo/validate/v3"
        "github.com/gobuffalo/validate/v3/validators"
        "github.com/gofrs/uuid"
)

//
// Database model
//

// Character is used by pop to map your characters database table to your go code.
type Character struct {
        ID uuid.UUID `json:"id" db:"id"`

        Name          string       `json:"name" db:"name"`
        Description   string       `json:"description" db:"description"`
        AvatarID      nulls.String `json:"avatar_id" db:"avatar_id"`
        Greeting      string       `json:"greeting" db:"greeting"`
        Persona       string       `json:"persona" db:"persona"`
        WorldScenario nulls.String `json:"world_scenario" db:"world_scenario"`
        ExampleChats  nulls.String `json:"example_chats" db:"example_chats"`
        Visibility    string       `json:"visibility" db:"visibility"`
        // IsNSFW        bool         `json:"nsfw" db:"nsfw"`

        Creator   User      `json:"-" belongs_to:"user"`
        CreatorID uuid.UUID `json:"-" db:"creator_id"`

        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

type Characters []Character

//
// View "models"
//

// FieldsForCharacterList contains the list of fields that should be used
// in the SQL SELECT query used on the List action for the Character resource.
var FieldsForCharacterList = []string{
        "id",
        "name",
        "description",
        "avatar_id",
        "visibility",
}

//
// Scopes
//

// CharactersVisibleToUser defines a scope to return only Characters that are visible to
// the user with the given UUID.
func CharactersVisibleToUser(userUuid uuid.UUID) pop.ScopeFunc <span class="cov0" title="0">{
        return func(q *pop.Query) *pop.Query </span><span class="cov0" title="0">{
                q = q.Where("(visibility = 'public' OR creator_id = ?)", userUuid)
                return q
        }</span>
}

//
// Validations
//

// Validate gets run every time you call a "pop.Validate*" (pop.ValidateAndSave, pop.ValidateAndCreate, pop.ValidateAndUpdate) method.
// This method is not required and may be deleted.
func (c *Character) Validate(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        // TODO(11b): All these hardcoded values might be better off at the top of the
        // file, or being defined somewhere else entirely.
        VALID_VISIBILITY_VALUES := []string{"public", "unlisted", "private"}

        return validate.Validate(
                &amp;validators.StringIsPresent{Field: c.Name, Name: "Name"},
                &amp;validators.StringLengthInRange{Field: c.Name, Name: "Name", Min: 1, Max: 32},

                &amp;validators.StringIsPresent{Field: c.Description, Name: "Description"},
                &amp;validators.StringLengthInRange{Field: c.Description, Name: "Description", Min: 12, Max: 64},

                &amp;validators.StringIsPresent{Field: c.Greeting, Name: "Greeting"},
                &amp;validators.StringLengthInRange{Field: c.Greeting, Name: "Greeting", Min: 2, Max: 1024},

                &amp;validators.StringIsPresent{Field: c.Persona, Name: "Persona"},
                &amp;validators.StringLengthInRange{Field: c.Persona, Name: "Persona", Min: 12, Max: 1024},

                &amp;validators.StringLengthInRange{Field: c.WorldScenario.String, Name: "Scenario", Min: 0, Max: 1024},
                &amp;validators.StringLengthInRange{Field: c.ExampleChats.String, Name: "Example chats", Min: 0, Max: 1024},

                &amp;validators.StringInclusion{Field: c.Visibility, Name: "Visibility", List: VALID_VISIBILITY_VALUES},
        ), nil
}</span>

// ValidateCreate gets run every time you call "pop.ValidateAndCreate" method.
// This method is not required and may be deleted.
func (c *Character) ValidateCreate(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        return validate.NewErrors(), nil
}</span>

// ValidateUpdate gets run every time you call "pop.ValidateAndUpdate" method.
// This method is not required and may be deleted.
func (c *Character) ValidateUpdate(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        return validate.NewErrors(), nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "log"

        "github.com/gobuffalo/envy"
        "github.com/gobuffalo/pop/v6"
)

// DB is a connection to your database to be used
// throughout your application.
var DB *pop.Connection

func init() <span class="cov8" title="1">{
        var err error
        env := envy.Get("GO_ENV", "development")
        DB, err = pop.Connect(env)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">pop.Debug = env == "development"</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "encoding/json"
        "strings"
        "time"

        "github.com/gobuffalo/nulls"
        "github.com/gobuffalo/pop/v6"
        "github.com/gobuffalo/validate/v3"
        "github.com/gobuffalo/validate/v3/validators"
        "github.com/gofrs/uuid"
        "github.com/pkg/errors"
        "golang.org/x/crypto/bcrypt"
)

// User is used by pop to map your users database table to your go code.
type User struct {
        ID uuid.UUID `json:"id" db:"id"`

        Email          string `json:"email" db:"email"`
        HashedPassword string `json:"hashed_password" db:"hashed_password"`
        DisplayName    string `json:"display_name" db:"display_name"`
        Role           string `json:"role" db:"role"`

        Characters Characters `has_many:"characters"`

        VerificationToken  nulls.String `json:"-" db:"verification_token"`
        PasswordResetToken nulls.String `json:"-" db:"password_reset_token"`

        // Used during registration.
        Password             string `json:"password" db:"-"`
        PasswordConfirmation string `json:"password_confirmation" db:"-"`

        LastLogin nulls.Time `json:"last_login" db:"last_login"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt time.Time  `json:"updated_at" db:"updated_at"`
}

// UserFromJWT is the user information contained within the JWT claim.
type UserFromJWT struct {
        ID          uuid.UUID `json:"id"`
        Email       string    `json:"email"`
        DisplayName string    `json:"display_name"`
}

// Marshals only the public fields from a UserFromJWT instance.
func (u *UserFromJWT) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(struct {
                ID          uuid.UUID `json:"id"`
                DisplayName string    `json:"display_name"`
        }{u.ID, u.DisplayName})
}</span>

// Marshals a User struct but only going over the public fields.
// https://stackoverflow.com/a/31374980
/* func (u *User) MarshalJSON() ([]byte, error) {
        return json.Marshal(struct {
                ID          uuid.UUID `json:"id"`
                Email       string    `json:"email"`
                DisplayName string    `json:"display_name"`
        }{u.ID, u.Email, u.DisplayName})
} */

// String is not required by pop and may be deleted
func (u User) String() string <span class="cov0" title="0">{
        ju, _ := json.Marshal(u)
        return string(ju)
}</span>

// Users is not required by pop and may be deleted
type Users []User

// String is not required by pop and may be deleted
func (u Users) String() string <span class="cov0" title="0">{
        ju, _ := json.Marshal(u)
        return string(ju)
}</span>

// Validates and creates a new User.
func (u *User) Create(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        u.Email = strings.ToLower(u.Email)
        u.Role = "user"

        pwdHash, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return validate.NewErrors(), errors.WithStack(err)
        }</span>

        <span class="cov0" title="0">u.HashedPassword = string(pwdHash)
        return tx.ValidateAndCreate(u)</span>
}

type EmailNotTaken struct {
        Name  string
        Field string
        tx    *pop.Connection
}

// Checks user's password for logging in.
func (u *User) Authorize(tx *pop.Connection) (*User, error) <span class="cov0" title="0">{
        err := tx.Select("id", "display_name", "hashed_password").Where("email = ?", strings.ToLower(u.Email)).First(u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Confirm that the given password matches the hashed password from the DB.
        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(u.HashedPassword), []byte(u.Password))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return u, nil</span>
}

// IsValid performs the validation check for unique emails
func (v *EmailNotTaken) IsValid(errors *validate.Errors) <span class="cov0" title="0">{
        query := v.tx.Where("email = ?", v.Field)
        queryUser := User{}
        exists, err := query.Exists(&amp;queryUser)
        if err != nil </span><span class="cov0" title="0">{
                errors.Add(validators.GenerateKey(v.Name), "We couldn't verify whether an account with this email already exists, please try again later.")
                return
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                errors.Add(validators.GenerateKey(v.Name), "An account with this email already exists.")
        }</span>
}

// Validate gets run every time you call a "pop.Validate*" (pop.ValidateAndSave, pop.ValidateAndCreate, pop.ValidateAndUpdate) method.
// This method is not required and may be deleted.
func (u *User) Validate(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        return validate.Validate(
                &amp;validators.EmailIsPresent{Field: u.Email, Name: "Email"},
                &amp;validators.StringLengthInRange{Field: u.Email, Name: "Email", Min: 8, Max: 96},
                &amp;EmailNotTaken{Name: "Email", Field: u.Email, tx: tx},

                &amp;validators.StringIsPresent{Field: u.Password, Name: "Password"},
                &amp;validators.StringIsPresent{Field: u.PasswordConfirmation, Name: "Password confirmation"},
                &amp;validators.StringsMatch{
                        Field:   u.Password,
                        Field2:  u.PasswordConfirmation,
                        Name:    "Password",
                        Message: "Passwords do not match.",
                },

                &amp;validators.StringIsPresent{Field: u.DisplayName, Name: "DisplayName"},
                &amp;validators.StringLengthInRange{Field: u.DisplayName, Name: "DisplayName", Min: 2, Max: 64},
        ), nil
}</span>

// ValidateCreate gets run every time you call "pop.ValidateAndCreate" method.
// This method is not required and may be deleted.
func (u *User) ValidateCreate(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        return validate.NewErrors(), nil
}</span>

// ValidateUpdate gets run every time you call "pop.ValidateAndUpdate" method.
// This method is not required and may be deleted.
func (u *User) ValidateUpdate(tx *pop.Connection) (*validate.Errors, error) <span class="cov0" title="0">{
        return validate.NewErrors(), nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
